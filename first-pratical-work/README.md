Neste algoritmo, a função evaluate é usada para calcular o valor da função objetivo f(x, y) para um determinado ponto (x, y), e a função ils implementa o algoritmo ILS com os parâmetros especificados. A solução inicial é escolhida aleatoriamente dentro dos limites dos intervalos especificados. O tamanho da vizinhança é definido pela variável neighborhood_size. O número máximo de iterações é especificado pela variável max_iterations, e o número máximo de iterações sem melhora é especificado pela variável max_iterations_without_improvement. Se o algoritmo não encontrar uma solução melhor após o número máximo de iterações sem melhora, a solução inicial é reiniciada aleatoriamente. A melhor solução encontrada é impressa no final do algoritmo.

Nesta implementação, a função f(x, y) implementa a função objetivo a ser minimizada. A função hill_climbing(start_x, start_y, step_size, max_iterations) implementa o algoritmo Hill Climbing para encontrar o mínimo local da função objetivo. Os parâmetros de entrada são start_x e start_y, que especificam o ponto de partida do algoritmo, step_size, que especifica o tamanho do passo a ser usado ao buscar os vizinhos do ponto atual, e max_iterations, que especifica o número máximo de iterações a serem executadas.

O algoritmo começa a partir do ponto especificado por start_x e start_y. Ele então busca os quatro vizinhos do ponto atual, cada um deles a uma distância step_size do ponto atual. O algoritmo calcula o valor da função objetivo para cada um dos vizinhos e seleciona o vizinho com o menor valor da função. Se o valor da função no vizinho selecionado for menor do que o valor atual da função no ponto atual, o algoritmo atualiza o ponto atual para o vizinho selecionado. Se o valor da função no vizinho selecionado for maior ou igual ao valor atual da função no ponto atual, o algoritmo retorna o ponto atual como o mínimo local encontrado. O algoritmo repete

$ pip install -r requirements.txt